* Scope

- DEX/биржа с полностью проверяемым исполнением и расчётом на цепи и при этом низкой задержкой и высокой пропускной способностью за счёт специализированного исполнения
- CEX-like UX
- ордербук
- perpetual futures (фьючерс, но без даты экспирации)
- ордера, стакан, сделки, позиции, маржа/ликвидации,
- спот-торговля: ордера, листинг активов, депозиты/выводы (через мост)
- On-chain state machine: все изменения состояния (ордера/сделки/маржа/ликвидации) детерминированы и подтверждаются консенсусом.
- суб-секундная финальность,
- высокая пропускная способность
- API для клиентов и ботов : HTTP/WS, публичные market data + приватные user streams.
- Наблюдаемость и эксплуатация : snapshot/restore, bounded stats, rate limits, защита от перегрузки.

* Notes

На Bitcoin L1 нельзя получить Hyperliquid-уровень скорости. Hyperliquid добивается его, потому что это отдельный высокопроизводительный L1, где каждый ордер/кансел/трейд/ликвидация пишутся ончейн и финализируются за один блок, а throughput заявляется на уровне ~200k orders/s.

Bitcoin Script сделан stateless и не turing-complete

Оракулы и деривативы на Bitcoin возможны, но не в формате быстрого ордербука

На Bitcoin есть протоколы деривативов через DLC (Discreet Log Contracts): контракт зависит от события, которое подтверждает оракул, и оракул при этом не обязан знать детали сделки https://bitcoinops.org/en/topics/discreet-log-contracts/

Чтобы получить UX как у Hyperliquid нужно:
- сайдчейн с быстрыми блоками и богатым исполнением
- бридж BTC туда-обратно

Что у нас есть из близкого к этому:
- https://bitvm.org/ - вычислительная парадигма для выражения Тьюринг-полных контрактов Биткоина. Работает как оптимистичный роллап. Доказывающий утверждает, что данная функция вычисляется для определенных входных данных и дает определенные выходные данные. Если это утверждение ложно, любой может выполнить мошенническое доказательство и наказать доказывающего. Используя этот механизм, любую вычислимую функцию можно проверить в Биткоине.
- Liquid Network - федеративный сайдчейн с одноминутными блоками, основанный на блокчейн-платформе Elements, форке кодовой базы Bitcoin с дополнительными функциями. Блоки создаются каждую минуту и ​​подписываются функционерами — специализированными серверами, управляемыми членами Федерации.
- https://rootstock.io - это платформа для создания смарт-контрактов на основе сайдчейна Биткоина и EVM, которая выступает в качестве L2 Биткоина. У него есть merge maining. Я не углублялся в детали, но начать можно отсюда: https://rootstock.io/blog/rootstock-fundamentals/
- https://www.stacks.co - Bitcoin-anchored smart contract platform and ecosystem organization focused on extending Bitcoin with programmable functionality. Свой консенсус (PoX), токен (STX) и язык смарт-контрактов (Clarity)
- Контрактные схемы типа DLC / каналы / гибриды. Хорошо для отдельных типов деривативов

Hyperliquid добивается UX тем, что контролирует весь вертикальный стек (консенсус → matching → риск).

* Допущения

- федерация/мультисиг/кастодиальная модель (быстро, но надо доверять группе)
- отдельная security-модель (PoS/BFT/и т.п.), которая не равна безопасности Bitcoin base layer
- модели торговли: централизованный лимитный стакан
- на собственном L1
- отдельная доменная среда для финансовых примитивов и EVM-совместимости.

* Как у них все устроено

- собственный алгоритм консенсуса (HyperBFT)
- HyperCore включает в себя ончейн-книги бессрочных фьючерсов и спотовых ордеров. Каждый ордер, отмена, сделка и ликвидация происходят прозрачно с одноблочной окончательностью. HyperCore поддерживает 200000 ордеров в секунду.
- HyperEVM - исполнение смарт-контрактов но на их блокчейне.

* Как мы можем это сделать

- L1 Chain : консенсус BFT-типа, оптимизированный под быстрый финалити и пропускную способность.
- Домен выполнения: специализированная VM/движок для биржевых примитивов (стаканы, маржа, ликвидации, vaults).
- EVM domain: EVM-совместимое исполнение внутри того же L1, наследующее безопасность консенсуса и умеющее взаимодействовать с core-примитивами.

** Компоненты

- Validator node: консенсус + выполнение state transitions.
- Sequencing/mempool: приём заявок, анти-спам, упорядочивание (как часть валидаторской логики).
- Matching engine (детерминированный): принимает входные ордер-операции и производит trades/обновления книги.
- Risk engine: маржа, лимиты, ликвидации, фондирование.
- Market data: генерация стримов (WS) из цепного состояния.

** Модель данных и состояния

Модель счета
- Счет / субсчета
- Остатки на балансе (обеспечение, прибыль/убыток, заблокированные средства)
- Позиции (по каждому активу)
- Открытые ордера (индексы/идентификаторы)
- Параметры риска (пределы кредитного плеча, поддерживающий запас)

Рыночная модель
- Определение рынка: символ, размер тика, размер лота, параметры маржи, параметры финансирования.
- Order book state: bids/asks, best levels, агрегированные уровни
- Входные данные для индексных/рыночных цен (оракул)

Модель хранилища
- Vault definition: стратегия, управляющий/параметры
- Учет акций: депозиты/снятие средств, распределение прибыли и убытков.
- Risk bounds: лимиты, паузы.
- Протокольный vault-маркетмейкер: отдельный объект, участвующий в MM и ликвидациях.

** Протокол операций (State transitions)

Это основа спеки. Для каждой операции:

place_order
- вход: market, side, price, size, tif, reduce_only, client_order_id…
- pre-checks: баланс/маржа/лимиты
- изменение: reserve funds, вставка в книгу или матчинг
- выход: trades[], order_status

отменить_заказ / отменить_все
- условия, идемпотентность

Проверяемые правила соответствия
- детерминированные правила price-time priority
- частичное заполнение
- комиссии

обновление финансирования
- расчёт funding, применение к позициям

ликвидация
- Условия срабатывания
- механизм (аукцион / страховой щит / хранилище / страховой фонд)
- защита от каскадных ликвидаций

пополнение/снятие средств
- мост/канонический ассет, финализация

*** Консенсус и сеть

- Политика блока: target block time, max tx/ops per block, приоритеты.
- DoS-защита: лимиты по IP/ключу, базовая плата/стейк, штрафы.
- Детализация детерминизма: одинаковый порядок операций, одинаковая математика (fixed-point), запрет nondeterministic syscalls.

*** API/Интеграции

Публичный контракт:

- API общедоступных данных
  - HTTP info endpoint: рынки, свечи, open interest, funding history, книги, etc.
  - WebSocket: стримы book/trades/liquidations/user updates; отдельные WS URL по сетям — в Hyperliquid так сделано.
- Торговый API
  - Подпись запросов (ED25519/secp256k1), nonce, защита от повторов
  - Rate limits + квоты
  - Семантика подтверждений: accepted vs finalized
- EVM domain API
  - RPC: eth_* методы, совместимость с кошельками
  - Газ/fee model: нативный токен, лимиты
  - Мост/transfer между core и EVM доменом (как отдельный набор транзакций/сообщений).

*** Операционка и наблюдаемость

- Снапшотинг
  - Версионированный формат снапшота состояния (минимум: заглушка формата + совместимость версий).
  - Быстрое восстановление валидатора и indexer’ов.
- Инкрементальные бюджеты (fairness budgets)
  - Единый механизм распределения времени/ресурсов между:
    - сетевой прием
    - Детерминированное сопоставление ордеров в стакане:
      - приоритет цены и времени
      - частичное заполнение
      - комиссии maker/taker
      - генерация сделок и обновлений книги
    - Risk (риск-движок). Проверки и изменения маржинального состояния:
      - хватает ли collateral, можно ли открыть/увеличить позицию
      - maintenance margin, расчёт доступного плеча
      - фондирование и применение к позициям
      - ликвидации, лимиты
    - GC/компактирование: очистка "мертвых" объектов состояния: отменённые/исполненные ордера, истёкшие заявки, старые индексы. Compaction сливает уровни, удаляет tombstones, переупорядочивает данные. В случае storage/журнала - "сборка" снапшота и выкидывание старых версий.
    - рендеринг/потоковая передача (WS)
- Introspection как протокол
  -  bounded stats (без опасных дампов), доступно remote UI/CLI
  -  метрики: лаги, очередь, p99-latency, размеры книг, число активных ордеров, частота ликвидаций

*** Индексация, аналитика и клиентские приложения

Indexer: репликация state transitions

Market data service: агрегаты, свечи

Пользовательский интерфейс: торговый терминал, портфель, панель управления рисками.

SDK: TypeScript/Python, примеры ботов
